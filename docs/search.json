{
  "articles": [
    {
      "path": "cheatsheets.html",
      "title": "Tidyverse Cheatsheets",
      "description": "재현가능한 연구 관련 Cheatsheets 모음 \n",
      "author": [],
      "contents": "\n\nContents\nRStudio 사용에 날개를 달다\nRStudio\n\n정적 문서와 웹앱을 만들어 보자\nrmarkdown\nshiny\n\n논문을 작성한다면\nLaTeX\n\n\nRStudio 사용에 날개를 달다\nRStudio\nRStudio IDE 사용 방법을 정리한 RStudio의 cheatsheet\n \n정적 문서와 웹앱을 만들어 보자\nrmarkdown\n동적 데이터분석 문서 작성을 지원하는 rmarkdown 패키지의 cheatsheet\n \nshiny\n반응형 웹 앱을 개발하는 shiny 패키지의 cheatsheet\n \n논문을 작성한다면\nLaTeX\n조판 전문 시스템인 LaTeX의 cheatsheet\n \n\n\n\n",
      "last_modified": "2021-11-05T08:12:44+09:00"
    },
    {
      "path": "chunk_knitr.html",
      "title": "청크 옵션 이해하기",
      "description": "knitr R 코드 청크의 옵션을 활용하는 방법을 익힙니다.\n",
      "author": [
        {
          "name": "유충현",
          "url": "https://choonghyunryu.github.io/"
        }
      ],
      "date": "2021-11-04",
      "contents": "\n\nContents\nR 마크다운 문서의 이해\nR 마크다운 문서의 분해\n튜토리얼의 범위\n\nknitr의 R 코드 청크\n청크의 구조 이해하기\nknitr의 R 코드 청크 옵션\n\n핸즈온 준비하기\n핸즈온 파일 다운로드하기\n\n핸즈온\n1. R 코드 출력 제어하기\n2. 플롯 출력하기\n\n요약\n핸즈온 요약\nI can do it\n\n\n\n\n\n\n\n들어가기\nRStudio의 R 마크다운은 기본적으로 knitr 코드 청크를 사용합니다.\n\n청크 옵션을 아는만큼 문서의 품질이 향상됩니다. 대표적인 청크 옵션을 사용하는 방법을 익혀서 여러분의 문서에 날개를 달아주기 바랍니다.\n\n\nR 마크다운 문서의 이해\nR 마크다운 문서의 분해\n앞서 만들었던 첫 R 마크다운 문서를 분해하면 다음과 같습니다.\nR 마크다운 문서의 분해YAML 헤더\nR 마크다운의 헤더 영역으로, 출력 문서를 세부적으로 제어합니다.\n\nR 코드 청크\n수행할 R 코드를 포함한 영역입니다.\n\n마크다운 태그를 포함한 텍스트\n문서의 서식과 텍스트를 정의하는 영역입니다.\n\n튜토리얼의 범위\n이 튜토리얼은 R 마크다운 문서의 분해 중에서의 knitr의 R 코드 청크 옵션을 이해할 목적으로 진행합니다. 대표적인 청크 옵션을 이해하고, 다루지 않는 다른 옵션의 사용을 시도할 수 있는 자신감 함양을 유도합니다.\nknitr의 R 코드 청크\n청크의 구조 이해하기\n우리는 지금 R 코드 청크를 다루고 있습니다. 그런데 knitr은 bash sehll(리눅스 쉘 스크립트), python(파이썬) 코드 청크 외에 몇개의 코드 청크를 지원합니다.\n예를 들어 R 마크다운에서 리눅스 쉘 스크립트 청크를 사용하려면 다음과 같이 기술합니다. 이것은 리눅스에서 날짜를 조회하는 명령어인 date를 수행한 후 그 결과를 마크다운 문서에 삽입합니다.\n\nbash 코드청크\n```{bash}\n# 날짜와 일시 출력\ndate\n\n# 'YYYY-MM-DD' 포맷의 날짜 출력\ndate +'%Y-%m-%d'\n```\n수행결과\n\n# 날짜와 일시 출력\ndate\n\n# 'YYYY-MM-DD' 포맷의 날짜 출력\ndate +'%Y-%m-%d'\n## Fri Nov  5 08:12:46 KST 2021\n## 2021-11-05\n\n\n브레이스({) 뒤에 오는 ’bash’는 bash 쉘이 코드 청크를 실행하라는 의미입니다. 그러면, R에게 실행을 요청하기 위한 청크는 다음과 같이 사용합니다. 당연히 브레이스 뒤에 ’r’이 따라옵니다.\n\n\n```{r 청크이름, 옵션이름=옵션값, 옵션이름=옵션값, ...}\nR 코드 삽입 영역\n```\n\n\n청크 이름은 청크를 식별하는 식별자입니다.\n청크 이름을 기술하지 않아도 청크는 정상적으로 수행됩니다.\nR 마크다운 컴파일의 진행경과\n오류가 발생하는 청크의 인식 등을 위해 기술하는 것이 좋습니다.\n\n옵션이름 = 옵션값 형식으로 옵션을 기술합니다.\n옵션을 기술하지 않아도 됩니다.\n이 경우에는 옵션의 기본 설정값이 적용됩니다.\n\nknitr의 R 코드 청크 옵션\nknitr 홈페이지의 https://yihui.org/knitr/options/ 페이지에는 청크 옵션에 대해서 잘 설명되어 있습니다.\n다음은 대표적인 청크 옵션의 목록입니다. 이 옵션들은 반드시 숙지하시기 바랍니다.\n코드와 결과 출력 관련 청크 옵션\n튜토리얼에서 익혀야 할 출력 관련 대표적인 청크 옵션입니다.\nR 코드와 결과 출력 관련 청크 옵션 목록\n옵션\n기본값\n기능\neval\nTRUE\n청크를 실행하고, 그 결과를 삽입하는 여부 설정\necho\nTRUE\n실행한 명령어도 함께 출력하는지의 여부 설정\nwarning\nTRUE\n경고 메시지의 출력 여부 설정\nerror\nFALSE\n에러 메시지의 출력 여부 설정\nmessage\nTRUE\n경고, 에러 외의 메시지의 출력 여부 설정\ntidy\nFALSE\nR 코드를 깔끔하게 정돈해서 출력할지의 여부 설정\ncomment\n“##”\n실행 결과 출력 각 라인의 앞에 넣을 prefix\n시각화 관련 청크 옵션\n튜토리얼에서 익혀야 할 시각화 관련 대표적인 청크 옵션입니다.\nR 코드와 결과 시각화 관련 청크 옵션 목록\n옵션\n기본값\n기능\nfig.width\n7\n출력을 위해 생성할 이미지 파일의 너비, 단위: 인치.\nfig.height\n7\n출력을 위해 생성할 이미지 파일의 높이, 단위: 인치.\nfig.align\n“default”\n플롯의 정렬 방법. \"left\", \"right\", \"center\"에서 선택\nfig.path\n‘figure/’\n시각화 이미지 파일을 저장할 디렉토리 경로\nfig.cap\nNULL\n플롯의 캡션 문자 정의\nout.width\n\n시각화가 화면에 출력되는 너비, 예) “75%”, “300px”\n핸즈온 준비하기\n핸즈온 파일 다운로드하기\n핸즈온 튜토리얼을 수행하기 위해서 아래 “청크 옵션 이해하기 튜토리얼 파일” 링크의 R 마크다운 파일을 다운로드합니다.\n링크에 마우스를 올려, 오른쪽 버튼으로 “다른이름으로 파일저장”을 실행합니다.\n\n다운로드한 파일을 RStudio로 읽어들입니다.\n청크 옵션 이해하기 튜토리얼 파일\n핸즈온\n1. R 코드 출력 제어하기\n1.1. R 코드와 함께 결과 출력하기\n\n다음 지문을 수행할, 분석 경험을 위해 코드와 결과를 공유할 청크를 만들려고 합니다.\niris 데이터에서 중복인 데이터가 1건 있습니다. 추출하여 출력해 보세요.\nR 코드와 결과를 함께 출력해 보세요.\n청크 이름은 ’dup_iris’로 정의합니다.\n\n’understand_chunk.Rmd’의 1-1. 빈 영역을 채우고 실행해 봅니다.\n모범 답안을 보지 않고 만들어 보세요.\n\n\n\n힌트 보기\n여러 방법이 있는데, 다음 코드를 사용해 보세요. \niris[duplicated(iris), ]\n모범 답안\n```{r dup_iris}\niris[duplicated(iris), ]\n```\n실행 결과\n\n\niris[duplicated(iris), ]\n\n\n##     Sepal.Length Sepal.Width Petal.Length Petal.Width   Species\n## 143          5.8         2.7          5.1         1.9 virginica\n\n\n\n1.2. 결과만 출력하기\n\n다음 지문을 수행할, 분석 결과만 공유할 청크를 만들려고 합니다.\nsummary() 함수로 iris 데이터의 각 변수들을 요약해 보세요.\n결과만 출력해 보세요.\n청크 이름은 ’dup_iris_result’로 정의합니다.\n\n’understand_chunk.Rmd’의 1-2. 빈 영역을 채우고 실행해 봅니다.\n모범 답안을 보지 않고 만들어 보세요.\n\n\n\n힌트 보기\n다음 코드를 사용해 보세요. \nsummary(iris)\n모범 답안\n```{r dup_iris_result, echo=FALSE}\nsummary(iris)\n```\n실행 결과\n\n##   Sepal.Length    Sepal.Width     Petal.Length    Petal.Width   \n##  Min.   :4.300   Min.   :2.000   Min.   :1.000   Min.   :0.100  \n##  1st Qu.:5.100   1st Qu.:2.800   1st Qu.:1.600   1st Qu.:0.300  \n##  Median :5.800   Median :3.000   Median :4.350   Median :1.300  \n##  Mean   :5.843   Mean   :3.057   Mean   :3.758   Mean   :1.199  \n##  3rd Qu.:6.400   3rd Qu.:3.300   3rd Qu.:5.100   3rd Qu.:1.800  \n##  Max.   :7.900   Max.   :4.400   Max.   :6.900   Max.   :2.500  \n##        Species  \n##  setosa    :50  \n##  versicolor:50  \n##  virginica :50  \n##                 \n##                 \n## \n\n\n\n1.3. 소스 코드만 출력하기\n\n소스만 설명하려 합니다. 즉, 소스를 실행하지 않고, 출력만 해야 합니다.\nsummary() 함수로 iris 데이터의 각 변수들을 요약하는 소스를 출력하세요.\n청크 이름은 ’iris_not_run’으로 정의합니다.\n\n’understand_chunk.Rmd’의 1-3. 빈 영역을 채우고 실행해 봅니다.\n모범 답안을 보지 않고 만들어 보세요.\n\n\n\n힌트 보기\n다음 코드를 사용해 보세요. \nsummary(iris)\n모범 답안\n```{r iris_not_run, echo=TRUE, eval=FALSE}\nsummary(iris)\n```\n실행 결과\n\n\nsummary(iris)\n\n\n\n\n\n1.4. 경고 메시지 출력하기\n\n다음을 수행해 보세요.\n-2부터 2까지의 정수 5개의 로그 값을 계산해 보세요.\n청크 이름은 ’log_integer’로 정의합니다.\n\n’understand_chunk.Rmd’의 1-4. 빈 영역을 채우고 실행해 봅니다.\n모범 답안을 보지 않고 만들어 보세요.\n\n어떤 결과가 출력되었나요?\n음수일 경우에 발생하는 경고 메시가 출력됨을 확인하세요.\n\n\n\n힌트 보기\n다음 코드를 사용해 보세요. \nlog(-3:3)\n모범 답안\n```{r log_integer}\nlog(-3:3)\n```\n실행 결과\n\n\nlog(-3:3)\n\n\n## Warning in log(-3:3): NaNs produced\n## [1]       NaN       NaN       NaN      -Inf 0.0000000 0.6931472\n## [7] 1.0986123\n\n\n\n1.5. 경고 메시지 출력하지 않기\n\n다음을 수행할 때 경고 메시지가 출력되는 것을 이미 알고 있습니다.\n-2부터 2까지의 정수 5개의 로그 값을 계산해 보세요.\n경고 메시지를 출력하고 싶지 않습니다.\n청크 이름은 ’no_warning’로 정의합니다.\n\n’understand_chunk.Rmd’의 1-5. 빈 영역을 채우고 실행해 봅니다.\n모범 답안을 보지 않고 만들어 보세요.\n\n\n\n힌트 보기\n다음 코드를 사용해 보세요. \nlog(-3:3)\n모범 답안\n```{r no_warning, warning=FALSE}\nlog(-3:3)\n```\n실행 결과\n\n\nlog(-3:3)\n\n\n## [1]       NaN       NaN       NaN      -Inf 0.0000000 0.6931472\n## [7] 1.0986123\n\n\n\n1.6. 커맨트 변경하기\n\n앞의 튜토리얼 결과를 보면, 출련된 각 라인에 “##”가 앞에 출력되었습니다.\nlm(Sepal.Width ~ Sepal.Length, data = iris)를 실행하세요.\n“##”가 보기 싫습니다. 차라리 출력되지 않았으면 좋겠습니다.\n청크 이름은 ’change_comment’로 정의합니다.\n\n’understand_chunk.Rmd’의 1-6. 빈 영역을 채우고 실행해 봅니다.\n모범 답안을 보지 않고 만들어 보세요.\n\n\n\n힌트 보기\ncomment 옵션을 사용합니다.\n모범 답안\n```{r change_comment, comment=\"\"}\nlm(Sepal.Width ~ Sepal.Length, data = iris)\n```\n실행 결과\n\n\nlm(Sepal.Width ~ Sepal.Length, data = iris)\n\n\n\nCall:\nlm(formula = Sepal.Width ~ Sepal.Length, data = iris)\n\nCoefficients:\n (Intercept)  Sepal.Length  \n     3.41895      -0.06188  \n\n\n\n2. 플롯 출력하기\n2.1. R 코드와 함께 플롯 출력하기\n\n다음 지문을 수행할, 분석 경험을 위해 코드와 결과를 공유할 청크를 만들려고 합니다.\niris 데이터에서 Sepal.Width ~ Sepal.Length 관계를 산점도로 시각화 하세요.\nSpecies별로 도형의 모양과 색상을 달리 그리세요.\nloess 산점도 위에 추세선도 출력하세요..\n\nR 코드와 결과를 함께 출력해 보세요.\n청크 이름은 ’scatter’로 정의합니다.\n\n’understand_chunk.Rmd’의 2-1. 빈 영역을 채우고 실행해 봅니다.\n모범 답안을 보지 않고 만들어 보세요.\n\n\n\n힌트 보기\n여러 방법이 있는데, 다음 코드를 사용해 보세요.\n\nlibrary(ggplot2)\n\nggplot(data = iris, aes(x = Sepal.Length, y = Sepal.Width, \n                        color = Species, shape = Species)) +\n  geom_point() +\n  geom_smooth()\n모범 답안\n```{r scatter}\nlibrary(ggplot2)\n\nggplot(data = iris, aes(x = Sepal.Length, y = Sepal.Width, \n                        color = Species, shape = Species)) +\n  geom_point() +\n  geom_smooth()\n```\n실행 결과\n\n\nlibrary(ggplot2)\n\nggplot(data = iris, aes(x = Sepal.Length, y = Sepal.Width, \n                        color = Species, shape = Species)) +\n  geom_point() +\n  geom_smooth()\n\n\n## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\n\n\n\n\n2.2. 플롯만 출력하기\n\n2.1. 결과에서 R 소스와 메시지의 출력 없이 플롯만 출력하려 합니다.\n청크 이름은 ’plot_only’로 정의합니다.\n\n’understand_chunk.Rmd’의 2-2. 빈 영역을 채우고 실행해 봅니다.\n모범 답안을 보지 않고 만들어 보세요.\n\n\n\n힌트 보기\n여러 방법이 있는데, 다음 코드를 사용해 보세요.\n\nggplot(data = iris, aes(x = Sepal.Length, y = Sepal.Width, \n                        color = Species, shape = Species)) +\n  geom_point() +\n  geom_smooth()\n모범 답안\n```{r plot_only, echo=FALSE, message=FALSE}\nggplot(data = iris, aes(x = Sepal.Length, y = Sepal.Width, \n                        color = Species, shape = Species)) +\n  geom_point() +\n  geom_smooth()\n```\n실행 결과\n\n\n\n\n\n2.3. 플롯 정렬하기\n\n2.2. 결과에서 플롯을 화면의 가운데 정렬로 출력하려 합니다.\n청크 이름은 ’plot_center’로 정의합니다.\n\n’understand_chunk.Rmd’의 2-3. 빈 영역을 채우고 실행해 봅니다.\n모범 답안을 보지 않고 만들어 보세요.\n\n\n\n힌트 보기\nfig.align 인수를 사용합니다.\n모범 답안\n```{r plot_center, echo=FALSE, message=FALSE, fig.align=\"center\"}\nggplot(data = iris, aes(x = Sepal.Length, y = Sepal.Width, \n                        color = Species, shape = Species)) +\n  geom_point() +\n  geom_smooth()\n```\n실행 결과\n\n\n\n\n\n2.4. 플롯 화면출력 크기 조절하기\n\n2.3. 결과에서 플롯을 화면의 영역의 1/2 사이즈로 출력하려 합니다.\n청크 이름은 ’plot_half_width’로 정의합니다.\n\n’understand_chunk.Rmd’의 2-4. 빈 영역을 채우고 실행해 봅니다.\n모범 답안을 보지 않고 만들어 보세요.\n\n\n\n힌트 보기\nout.width 인수를 사용합니다.\n모범 답안\n```{r plot_half_width, echo=FALSE, message=FALSE, fig.align=\"center\", out.width=\"50%\"}\nggplot(data = iris, aes(x = Sepal.Length, y = Sepal.Width, \n                        color = Species, shape = Species)) +\n  geom_point() +\n  geom_smooth()\n```\n실행 결과\n\n\n\n\n\n2.5. 플롯 출력에 캡션 넣기\n\n2.3. 결과에 캡션을 출력하려 합니다.\n“iris 품종별 산점도”라는 캡션을 추가합니다.\n청크 이름은 ’plot_caption’으로 정의합니다.\n\n’understand_chunk.Rmd’의 2-5. 빈 영역을 채우고 실행해 봅니다.\n모범 답안을 보지 않고 만들어 보세요.\n\n\n\n힌트 보기\nfig.cap 인수를 사용합니다.\n모범 답안\n```{r plot_caption, echo=FALSE, message=FALSE, fig.align=\"center\", fig.cap=\"iris 품종별 산점도\"}\nggplot(data = iris, aes(x = Sepal.Length, y = Sepal.Width, \n                        color = Species, shape = Species)) +\n  geom_point() +\n  geom_smooth()\n```\n실행 결과\n\n\n\n(#fig:plot_caption)iris 품종별 산점도\n\n\n\n\n\n요약\n핸즈온 요약\nknitr 청크의 종류별로 다양한 출력 포맷의 문서를 작성했습니다.\nknitr 시각화 컨트롤 청크를 이용해서 플롯을 다양하게 출력했습니다.\nI can do it\nknitr의 대표적인 청크 옵션을 숙지해서, 화면에 분석 결과와 플롯 출력의 모양을 원하는대로 조정할 수 있습니다.\n\n\n\n",
      "last_modified": "2021-11-05T08:12:51+09:00"
    },
    {
      "path": "create_help.html",
      "title": "BitStat 도움말 추가하기",
      "description": "BitStat에 도움말을 추가하고 소스를 배포할 수 있습니다.\n",
      "author": [
        {
          "name": "유충현",
          "url": "https://choonghyunryu.github.io/"
        }
      ],
      "date": "2021-10-31",
      "contents": "\n\nContents\nNot Yet\n요약\n핸즈온 요약\nI can do it\n\n\n\n\n\n\n\n\n들어가기\nooooooooooooooooooooooooooooooooooo.\n\nooooooooooooooooooooooooooooooooooo.\n\n\nNot Yet\n요약\n핸즈온 요약\nI can do it\n\n\n\n",
      "last_modified": "2021-11-05T08:12:52+09:00"
    },
    {
      "path": "help.html",
      "title": "BitStat 도움말 작성하기",
      "description": "BitStat에서 도움말을 작성하는 방법을 숙지합니다.",
      "author": [],
      "contents": "\nBitStat 도움말 매커니즘\nBitStat 도움말 매커니즘은, 미리 만들어 놓은 정적 HTML 파일을 Shiny 앱에 넣는 방법을 사용합니다. 그래서 우리는 이미 앞의 R Markdown 핸즈온에서 웹 문서를 생성하는 방법을 익혔습니다.\nBitStat 패키지의 구조\nBitStat 패키지의 구조는 다음과 같습니다. Shiny 앱을 패키지로 빌드할 경우에는 ./inst 디렉토리 내에 앱을 위치시킵니다.\nBitStat 패키지의 구조./inst 디렉토리 아래의 디렉토리 용도는 다음과 같습니다.\napp : Shiny 앱 디렉토리\nhelp : 도움말 경로\nimg : 도움말 삽입 이미지 경로\n\nmenu : 메뉴별 UI/Server 로직 경로\ntools : UI/Server를 지원하는 함수 경로\nwww : 웹 관련 경로 (Reserved, Not used)\nimg : 웹 이미지 경로\nmeta : 웹 메타 경로\n\n\ntranslation : 메뉴/메시지 i18n 지원 메타 파일 경로\nBitStat 패키지의 도움말 상세 구조\n도움말의 구조를 살펴 보기 위해서 파일 레벨까지 구조를 확장해 보겠습니다. app 디렉토리 이하의 경로에 생성된 파일입니다. (2021-10-26 기준)\nBitStat 패키지의 app 디렉토리 이하 구조여기서 도움말과 관련된 경로는 help와 menu 디렉토리입니다. help 디렉토리에는 도움말 파일이 위치해 있습니다. 그리고 menu 디렉토리는 도움말 파일을 핸들링하는 help_ui.R 파일이 위치합니다.\n도움말 파일\n도움말 파일은 R Markdown으로 만듭니다. 파일은 inst > app > help 경로에 보관하고 HTML 파일로 빌드합니다.\n다국어 지원 (i18n)\n현재 BitStat는 한글과 영문 도움말을 지원합니다. 그리고 이들은 파일 이름의 접미어(postfix)로 구분합니다.\n한글 도움말 파일\n*_kr.Rmd : 한글 도움말 생성을 위한 R Markdown 문서 이름\n사례 : data_diagnose_kr.Rmd\n\n*_kr.html : 한글 도움말 파일 이름\n사례 : data_diagnose_kr.html\n\n\n영문 도움말 파일\n*_en.Rmd : 영문 도움말 생성을 위한 R Markdown 문서 이름\n사례 : data_diagnose_en.Rmd\n\n*_en.html : 영문 도움말 파일 이름\n사례 : data_diagnose_en.html\n\n\n도움말 파일 만들기\n도움말을 위한 R Markdown 파일을 만든 후, 해당 경로에 HTML 파일을 빌드합니다.\n다음은 도움말을 작성하기 위한 R Markdown 파일의 예시입니다.\n도움말 작성 R Markdown 파일\n\n\n\n솔루션\n\n아직 R 마크다운에 익숙하지 않다면, 'R Markdown의 이해'와 'R Markdown hands-on'을 숙지한 후 도움말을 작성하시기 바랍니다.\n\n\n\n\n\n",
      "last_modified": "2021-11-05T08:12:52+09:00"
    },
    {
      "path": "index.html",
      "title": "BitStat 도움말",
      "description": "오픈 통계 패키지인 **BitStat**는 통계용어를 한글로 최적 번역하였으며, 다국어를 지원하기 때문에 영문 메뉴와 메시지도 지원하고 모든 기능에 대해서 한글과 영문 도움말을 제공합니다. \n",
      "author": [],
      "contents": "\n다국어 지원 (i18n)\nBitStat은 메뉴와 메시지 등 UI 레벨에서 한글과 영문을 지원합니다.\n한글 지원 BitStat영문 지원 BitStat도움말 기능\nBitStat은 제공하는 모든 기능에 대해서 도움말을 제공하고 있습니다. 도움말도 다국어를 지원하기 때문에 사용자의 환경에 따라서 한글과 영문으로 제공합니다.\nBitStat의 도움말 화면\n\n\n",
      "last_modified": "2021-11-05T08:12:53+09:00"
    },
    {
      "path": "rmarkdown_yaml.html",
      "title": "YAML 이해하기",
      "description": "YMAL 헤더의 변경으로 문서의 형식과 모양이 바꾸는 것을 이해합니다.\n",
      "author": [
        {
          "name": "유충현",
          "url": "https://choonghyunryu.github.io/"
        }
      ],
      "date": "2021-11-05",
      "contents": "\n\nContents\nR 마크다운 문서의 이해\nR 마크다운 문서의 분해\n튜토리얼의 범위\n\nYAML 헤더의 이해\nYAML 헤더는 무엇인가요?\nYAML 헤더 예제\n\n문서파일 형식 변경\n핸즈온 파일 준비하기\nMS 워드파일 생성\n\n요약\n핸즈온 요약\nI can do it\n\n\n\n\n\n\n\n들어가기\n문서 파일의 형식을 바꾸거나 전체 페이지의 테마를 바꾸고 싶다구요?!\n\nYAML로 문서 형식을 바꾸고 테마를 변경해 보세요. 그리고 덤으로 R 코드 실행을 위한 파라미터 값 설정으로 같은 포맷 다른 결과의 문서를 만들 수 있습니다.\n\n\nR 마크다운 문서의 이해\nR 마크다운 문서의 분해\n앞서 만들었던 첫 R 마크다운 문서를 분해하면 다음과 같습니다.\nR 마크다운 문서의 분해YAML 헤더\nR 마크다운의 헤더 영역으로, 출력 문서를 세부적으로 제어합니다.\n\nR 코드 청크\n수행할 R 코드를 포함한 영역입니다.\n\n마크다운 태그를 포함한 텍스트\n문서의 서식과 텍스트를 정의하는 영역입니다.\n\n튜토리얼의 범위\n이 튜토리얼은 R 마크다운 문서의 분해 중에서의 YAML 헤더를 이해할 목적으로 진행합니다. 동일한 R 마크다운 문서로 어떻게 이질적인 형식의 파일과 모양을 빚어낼 수 있는지를 경험해 보세요.\nYAML 헤더의 이해\nYAML 헤더는 무엇인가요?\nYAML는 ’또 다른 마크업 언어(Yet Another Markup Language)’를 의미합니다. 복작하고 어렵게 생각하지 마시고 생성할 문서 전체의 형식을 정의하는 헤더라고 이해하면 됩니다.\n헤더라는 의미는 R 마크다운 문서의 맨 앞에 위치한다는 것을 의미합니다. 그리고 YAML라는 것을 알려주기 위해서 청크는, “---”으로 시작해서 “---”로 끝납니다.\nYAML 헤더 예제\n이미 우리는 YAML 헤더를 경험했습니다.\n---\ntitle: \"첫 R 마크다운\"\nauthor: \"홍길동\"\ndate: \"10/31/2021\"\noutput: html_document\n---\nYAML 헤더에서 이름과 값은 콜론(:)으로 구분합니다. 한 줄에 한 쌍의 이름과 값이 올 수 있습니다.\ntitle: “첫 R 마크다운”은 문서 제목(타이틀)이 “첫 R 마크다운”임을 의미합니다. 그리고 output: html_document은 생성할 문서 파일이 HTML, 즉 웹 문서임을 rmarkdown 패키지에게 알려줍니다. 그러면 rmarkdown 패키지가 pandoc을 호출하서 웹 문서를 생성하게 됩니다.\n문서파일 형식 변경\n핸즈온 파일 준비하기\n“첫 R 마크다운 문서 만들기” 핸즈온에서 생성한 “first_rmarkdown.Rmd” 파일을 이용하여 핸즈온을 진행하려 합니다.\n만약 파일이 없다면,\n핸즈온 튜토리얼을 수행하기 위해서 아래 “YAML 이해하기 튜토리얼 파일” 링크의 R 마크다운 파일을 다운로드합니다.\n링크에 마우스를 올려, 오른쪽 버튼으로 “다른이름으로 파일저장”을 실행합니다.\n\n다운로드한 파일을 RStudio로 읽어들입니다.\nYAML 이해하기 튜토리얼 파일\nMS 워드파일 생성\n요약\n핸즈온 요약\nI can do it\n\n\n\n",
      "last_modified": "2021-11-06T23:46:45+09:00"
    },
    {
      "path": "rmarkdown.html",
      "title": "R Markdown의 이해",
      "description": "재현가능한 연구의 개념과 Sweave, knitr, rmarkdown을 통해 R Markdown을 이해합니다.  \n",
      "author": [
        {
          "name": "유충현",
          "url": "https://choonghyunryu.github.io"
        }
      ],
      "date": "2021-10-30",
      "contents": "\n\nContents\n재현가능한 연구\n마크업 언어\n마크다운\nLaTeX\nPandoc\n\nSweave\nSweave 매커니즘\nSweave 예제\n\nknitr 패키지\nR 마크다운 파일\nknitr 매커니즘\nknitr 예제\n\nrmarkdown 패키지\n\n재현가능한 연구\n‘재현가능한 연구’(Reproducible Research)라는 용어가 생소할 수 있으나 R 세계에서는 제법 회자되는 용어로, 공개한 연구의 결과물이 재현되고 검증될 수 있도록 하는 것을 의미합니다. 이 방법은 결국 연구가 발전하는 방향으로 재창조되는 결실을 가져옵니다. 이를 위해서는 데이터 분석의 방법을 실험 데이터에 연결하여 재현 검증될 수 있는 체계를 구축해야 합니다.\n재현가능한 연구를 이해하기 쉬운 사례로 설명하겠습니다. 데이터 입출력 및 분석 로직과 분석 결과를 표현하는 R 스크립트를 R 마크다운 문서에 정리합니다. R 마크다운 문서에는 연구에 대한 자세한 설명과 결과 해석이 포함되어 있고, 별도의 공간에 파일로 저장된 원시 데이터도 경로를 통해 문서와 연결되어 있습니다. 이 R 마크다운 문서와 데이터 파일을 RStudio 프로젝트나 R 패키지에 포함하여 배포하면 누구나 동일한 결과를 재현할 수 있게 됩니다.\n공개한 연구 자료에는 데이터, 분석을 위한 R 코드 및 과정의 설명과 결과의 해석 모두 포함되어야 합니다. 그러므로 재현가능한 연구는 공유의 가치를 인정하는 오픈소스 정신이 깃들여 있는 셈입니다.\nCRAN Task View: Reproducible Research에는 재현가능한 연구를 지원하는 여러 R 패키지를 소개하고 있습니다. 페이지에 방문하면 아마 많은 패키지와 다양한 기능의 소개에 놀랄 것입니다. 또한 방대한 기능에 무엇인 재현가능한 연구인지 이해하기 어려울 수 있습니다.\n이 글에서는 R 패키지가 지원하는 여러 기능 중에서 다음 두 가지 사례를 통해서 재현가능한 연구를 소개하겠습니다.\nLaTeX에 포함된 R 코드를 수행하여 PDF 문서를 만드는 사례와 관련 리소스\nR 마크다운 문서로 분석 결과가 포함된 HTML 보고서를 만드는 방법과 관련 리소스\n마크업 언어\n여러분은 웹 브라우저에 표현되는 컨텐츠(웹 페이지나 웹 어플리케이션)는 HTML로 구현된다는 것은 알고 계실겁니다. 그런데 HTML은 “Hyper Text Markup Langaue”의 약자라는 것은 아시나요? 그리고 영어의 정확한 의미를 아시나요?\n‘Text’(텍스트)는 의미의 전달을 목적으로, 알파벳, 한글, 숫자, 기호 등의 문자 세트로 문서나 글을 표현한 것입니다. 우리는 텍스트를 순차적으로 읽으면서 전달하는 의미를 이해하게 됩니다.\n‘Hyper Text’(하이퍼 텍스트)는 사전적으로 “텍스트를 뛰어넘는다”는 의미입니다. 웹 페이지는 본문에 다른 페이지로 이동하는 링크 기능을 이용해서 다른 페이지나, 페이지의 다른 영역으로 이동하는 링크 기능으로 페이지 내의 다른 문장의 영역으로 넘나들 수 있습니다. HTML에서는 이 링크를 하이퍼 링크(hyper link)라고 부릅니다. 즉, 하이퍼 링크를 통해서 텍스트를 비순차적으로 읽으면서, 순차적 전달보다 의미를 좀 더 쉽게 이해할 수 있습니다. 이것이 하이퍼 텍스트의 개념입니다.\n통상적으로 ‘텍스트 파일’은 서식이 없는 텍스트로 구성되어서, 어떤 에디터로도 쉽게 읽을 수 있는 파일을 의미합니다. 그러나 텍스트에 서식이 포함된 즉, 타이틀이나 주석, 볼드와 이탤릭처럼 폰트 페이스 등의 서식을 사용하거나 설명을 위해 이미지 삽화가 포함된 파일은 텍스트 에디터로는 읽을 수 없습니다. 별도의 프로그램으로만 열어볼 수 있습니다. HTML의 하이퍼 텍스트는 이러한 서식을 포함하고 있기 때문에 에디터가 아닌 웹 브라우저를 통해 읽어야 합니다.\n‘Markup Langaue’(마크업 언어)는 텍스트의 특정 위치에 표시를 하는 것을(마크업) 통해서 문서를 구조적으로 표현하는 컴퓨터 언어를 의미합니다. 물론 HTML에서의 구조적인 표현은 서식의 표현이나 페이지 간의 이동이나 페이지 내에서의 이동 등을 의미합니다.\n마크업 언어는 태그(tag) 등을 이용해서 문서나 데이터의 구조를 설명합니다. 즉 마크업이라는 작업에 태그를 이용하는 것입니다. 그래서 마크업 언어의 문법적 특징은 태그에 나타나게 됩니다.\n몇개의 HTML 태그를 예시하면, 하이퍼 링크 태그인 <a><\/a>는 하이퍼 링크를 정의하며, 이미지 태그인 <img />로 웹 페이지에 이미지를 삽입합니다.\n마크다운\n마크업 언어의 하나인 마크다운(Markdown)은 읽기 쉽고 쓰기 쉬운 양식을 작성하기 위해서 만들어졌습니다. 사용법이 매우 쉽기 때문에 빠르게 서식이 있는 문서를 만들 수 있습니다.\n\n\n\n\n\n\n\n“마크다운(Markdown)은 일반 텍스트 기반의 경량 마크업 언어입니다. 일반 텍스트로 서식이 있는 문서를 작성하는 데 사용되며, 일반 마크업 언어에 비해 문법이 쉽고 간단한 것이 특징입니다. HTML과 리치 텍스트(RTF)1 등 서식 문서로 쉽게 변환되기 때문에 응용 소프트웨어와 함께 배포되는 README 파일이나 온라인 게시물 등에 많이 사용됩니다.”2\n\n\nLaTeX\n저작을 위한 전문 시스템인 LaTeX(레이택)은 일반 R 사용자가 사용하기에는 다소 여렵지만 출력물의 퀄리티가 높아서 선호되기도 합니다.\n\n\n\n\n\n\n\nLaTeX(레이택)은 논문이나 출판물 등의 문서를 작성하는 데 쓰이는 전문 조판 시스템입니다. LaTeX은 수식과 다이어그램을 많이 사용하고, 도표와 이미지 삽입이 빈번한 이공계열에서 논문을 작성에 사용하고 있습니다. 또한 서적 등을 출판하는 출판업계에서도 사용하고 있습니다.\n\n\nPandoc\nRStudio를 설치하면 Pandoc(판독)도 함께 설치됩니다. 그 이유는 RStudio 기능에 재현가능한 연구를 위한 여러 문서 작성 기능이 있는데, Pandoc이 약방의 감초처럼 사용되기 때문입니다.\n\n\n\n\n\n\n\n“Pandoc은 마크업 형식을 다른 마크업 형식으로 변환해주는 라이브러리입니다. Pandoc은 Markdown, HTML, LaTeX 및 Word docx 등 수많은 마크업과 워드 프로세싱 형식 간에 변환을 수행합니다.”3\n\n\nSweave\nR 재단의 멤버십 회원인 오스트리아의 Friedrich Leisch가 2002년에 만든, utils 패키지의 Sweave(Leisch 2002) 함수는 자동으로 리포트는 생성해 주는 함수입니다.\nSweave는 S를 이용한 데이터 분석과 LaTeX 조판을 통합하여 데이터 분석 보고서를 작성합니다. S는 상용 S+와 오픈소스 R을 의미합니다. 아마 요즘에 개발되었다면 함수 이름을 Rweave로 작명했을 것입니다. 왜냐하면 2000년대 초반에는 R보다는 S+의 명성이 더 컸기 때문입니다.\nSweave라는 이름은 “S” 와 “Weave”를 결합한 복합어입이다. 그러므로 이 함수는 “에스 위브”라 읽어야 합니다. “Weave”는 날실(직물의 길이 방향, 즉 세로로 놓인 실)과 씨실(직물의 너비 방향, 즉 가로로 놓인 실)로 직물을 짜는 것을 의미하는 동사입니다. 즉 직물을 짜듯, S(S+와 R)의 코드를 LaTeX 조판 코드와 잘 결합하여 완성된 데이터 분석 보고서(직물)를 생성한다는 의미입니다.\n정리하자면, Sweave는 R 코드의 실행 결과(데이터 분석의 출력 정보, 표, 그래프 등)를 LaTeX 파일에 자동 삽입합니다. 그리고 이 LaTeX 파일로 PDF을 조판하여 최종 보고서를 생성하는 것입니다.\nSweave의 단점은 LaTeX과 결합하여 PDF 파일만 생성한다는 점입니다. 2000년대 초반에는 S 사용자의 많은 수가 LaTeX을 사용할 수 있는 통계학자였고, 학술지 등에 LaTeX으로 만들어진 논문을 투고해야 했기에 이 조합은 매우 유용하였습니다. 그러나 최근의 데이터 과학 필드에서는 HTML 기반으로 보고서를 작성하는 경우가 많기 때문에, HTML을 포함한 다양한 포맷의 보고서를 생성할 수 없다는 것은 단점일 수 밖에 없습니다.\nSweave 매커니즘\nS 코드 청크(Chunk, 덩어리)는 특정 작업을 수행하는 S 스크립트(이하 R 스크립트로 표현합니다)를 의미합니다. LaTeX으로 만들어진 날실 곧곧에 R 코드인 씨실을 넣기 위해서 코드 청크를 사용합니다.\nLaTeX 파일에 삽입하는 코드 청크는 다음의 포맷을 따릅니다.\n\n<<Sweave 옵션 영역>>=\nR 코드 삽입 영역\n@    \n\nSweave는 LaTeX 파일을 읽어 ‘<<>>=’ 과 ‘@’ 사이의 R 코드를 실행한 후, 실행 결과를 해당 위치의 LaTeX 파일에 삽입합니다. ‘<<’과’>>=’ 사이에 기술할 수 있는 Sweave 옵션은 다양한 출력을 제어할 수 있습니다. 예를 들면 플롯의 크기를 조정하거나 출력 텍스트의 서식을 제어할 수 있습니다. 경우에 따라서 실행 결과와 함께 R 코드도 출력할 수도 있습니다.\nR 코드의 실행 결과가 삽입된 LaTeX 파일은 LaTeX 시스템의 pdfLaTex이나 XeLaTeX 프로그램을 통해서 PDF 파일로 변환됩니다. Sweave 파일은 확장자로 “Rnw”를 사용해야 합니다. 그런데 이 확장자는 대소문자를 구별하지 않습니다만 관행적으로 첫 문자를 대문자로 표현합니다.\nRStudio는 이 몇 단계 과정을 한번에 엮어 실행합니다. 그래서 바로 PDF 파일을 만들어줍니다.\nSweave 예제\nSweave(Leisch 2002)에 삽입된 짧은 예제 파일을 살펴보겠습니다. example-1.Rnw 파일의 LaTeX 스크립트 중간에 R 코드가 삽입된 코드 청크 영역을 주의깊게 살펴보십시요.\n\n\\documentclass[a4paper]{article}\n\n\\begin{document}\nIn this example we embed parts of the examples from the\n\\texttt{kruskal.test} help page into a \\LaTeX{} document:\n\n<<>>=\ndata(airquality)\nkruskal.test(Ozone  ̃ Month, data = airquality)\n@\nwhich shows that the location parameter of the Ozone\ndistribution varies significantly from month to month.\nFinally we include a boxplot of the data:\n\n\\begin{center}\n<<fig=TRUE,echo=FALSE>>=\nboxplot(Ozone  ̃ Month, data = airquality)\n@\n\\end{center}\n\n\\end{document}\n\n\nSweave 파일은 Sweave에 의해서 다음과 같은 완전한, example-1.tex이라는 이름의 LaTex 파일로 변환됩니다. 시각화 결과는 example-1-002.pdf 파일로 따로 저장되게 됩니다.\n\n\\documentclass[a4paper]{article}\n\n\\usepackage{Sweave}\n\\begin{document}\n\nIn this example we embed parts of the examples from the\n\\texttt{kruskal.test} help page into a \\LaTeX{} document:\n\n\\begin{Sinput}\n> data(airquality)\n> kruskal.test(Ozone ~ Month, data = airquality)\n\\end{Sinput}\n\\begin{Soutput}\n      Kruskal-Wallis rank sum test\ndata: Ozone by Month\nKruskal-Wallis chi-squared = 29.2666, df = 4, p-value = 6.901e-06\n\\end{Soutput}\nwhich shows that the location parameter of the Ozone\ndistribution varies significantly from month to month.\nFinally we include a boxplot of the data:\n\n\\begin{center}\n\\includegraphics{example-1-002}\n\\end{center}\n\n\\end{document}\n\n\n마지막으로 LaTeX 파일을 pdfLaTex으로 변환하면 다음과 같은 PDF 문서가 만들어집니다.\nPDF 문서 내용knitr 패키지\n2010년대부터 R 필드의 패러다임 전환이 시작됩니다. 데이터 과학(data science)이 발전하면서 기존 통계학자들의 기여가 많았던 R 개발 진영에 데이터 과학자, 데이터 엔지니어, 프로그램 개발자들이 대거 활동하기 시작하면서 R 분석의 변화를 맞습니다.\n데이터 모델링 분야에서는 개별 함수들을 이용한 방법에서 Max Kuhn의 caret(2007) 패키지로, 데이터 시각화 분야에서는 R 그래픽 함수와 lattice 패키지에서 Hadley Wickham의 ggplot2(2007)로 진화합니다. 데이터 엔지니어링에서도 Hadley Wickham의 dplyr(2014)가 기존 데이터 프레임 연산을 대체합니다.\ncaret 패키지를 제외한 ggplot2, dplyr 패키지에 협업 가능한 유용한 패키지들이 에코 패키지로 결합하여 tidyverse 패키지군이 태동합니다. 이들은 RStudio라는 회사를 구심점으로 많은 유용한 패키지를 개발합니다. 특히 Hadley Wickham을 중심으로 많은 데이터 과학자와 데이터 엔지니어, 웹 개발자들이 두각을 나타냅니다.\n재현가능한 연구 분야도 발전하게 됩니다. Sweave의 단점을 보완하고 여러 유용한 기능을 추가한 knitr 패키지가 2012년 Yihui Xie에 의해 개발됩니다. 이제 데이터 분석 결과를 LaTeX 시스템 기반의 PDF로 조판하는 시대를 넘어서 HTML 기반의 WEB 채널로 배포되고 공유하는 시대가 도래한 것입니다.\n\n\n\n\n\n\n\n“Sweave에서 영감받은 knitr 패키지는 다른 애드온 패키지를 하나의 패키지로 결합4하여, R을 이용해서 동적으로 리포트를 생성하기 위해서 개발되었습니다.”5  이제 재현 가능을 연구를 위한 보고서 작성이 PDF를 넘어 HTML로 확장되고, 그 성능도 향상되기 시작합니다.\n\n\nknitr도 “knit”와 “R”을 결합한 복합어입이다. 그래서 “니트 알”로 발음해야 합니다. “knit”는 스웨터와 같은 옷을 뜨게질하는 것을 의미합니다. Sweave의 “Weave”가 직물을 직조하는 것과 동일한 의미입니다. 패키지 이름을 작명하는 것에도 위트가 숨어 있습니다. 마크다운 문서 곳곳에 다른 색상의 R이라는 털실로 뜨게질해서 무늬가 있는 스웨터(보고서)를 만드는 역할을 표현한 것입니다.\nR 마크다운 파일\n‘R 마크다운’(R Markdwon) 파일은 재현 개능한 연구를 위해서, 마크다운 문서에 R 코드 청크를 삽입한 파일입니다. 확장자로 “Rmd”를 사용하는데, 확장자는 Sweave 파일처럼 대소문자를 구별하지 않습니다.\nknitr 매커니즘\nknitr는 R 마크다운 파일의 R 코드 청크를 실행해서 그 결과를 마크다운 문서와 결합한 마크다운 파일을 생성합니다. 마크다운 파일의 확장자는 “md”입니다.\nknitr의 R 코드 청크는 다음의 포맷을 따릅니다.\n\n\n```{r, knitr 옵션 영역}\nR 코드 삽입 영역\n```    \n\n\nknitr는 R 마크다운 파일을 읽어 백틱(`) 문자 세개로 구성된 ‘```{r}’ 과 ‘```’ 사이의 R 코드를 실행한 후, 실행 결과를 해당 위치의 파일에 삽입하여 마크다운 문서를 생성합니다. 옵션은 다양한 출력을 제어할 수 있습니다. 예를 들면 플롯과 출력 텍스트의 서식을 제어할 수 있는 것은 물론 결과를 캐싱해서, 다음 작업에는 연산을 수행하지 않고 결과를 캐시에서 가져올 수도 있습니다.\nSweave가 Sweave 파일을 LaTeX 파일까지만 생성하고, pdfLaTeX 유틸리티가 LaTeX 파일을 PDF 파일로 변환하는 것처럼, knitr는 R 마크다운 파일을 마크다운 파일까지만 생성합니다. 그리고 pandoc이 마크다운 파일을 원하는 포맷의 문서 파일로 변환합니다. 두 방법의 차이점은 pdfLaTeX가 PDF 파일만 생성하는 것에 반해서, pandoc은 PDF를 포함해서 HTML, 워드, 파워포인트 파일까지 다양한 파일을 생성합니다.\nknitr는 Sweave 파일도 처리할 수 있습니다. 이 경우는 knitr 패키지의 Sweave2knitr 함수가 Sweave 파일을 R 마크다운로 변환한 다음에 작업합니다. 그러나 호환성이 다소 떨어지고, kintr의 다양한 기능으로 Sweave이 아니라 knitr을 사용하는 것을 권장합니다.\nknitr 예제\nSweave(Leisch 2002)에 삽입된 예제를 example-1.Rmd이라는 이름의 다음과 같은 R 마크다운 파일로 생성하였습니다.\n\n\nIn this example we embed parts of the examples from the\n*kruskal.test* help page into a LaTeX document:\n\n```{r}\ndata(airquality)\nkruskal.test(Ozone ~ Month, data = airquality)\n```\nwhich shows that the location parameter of the Ozone\ndistribution varies significantly from month to month.\nFinally we include a boxplot of the data:\n\n```{r, echo=FALSE}\nboxplot(Ozone ~ Month, data = airquality)\n```  \n\n\n\n그리고 knitr 패키지의 knit 함수를 이용해서 마크다운 파일로 변경합니다.\n\n\nlibrary(knitr)\n\nknit(\"example-1.Rmd\")\n\n\n\n생성된 마크다운 파일인 example-1.md는 다음과 같습니다.\n생성된 마크다운 파일knitr 패키지의 pandoc 함수는 Pandoc을 랩핑한 함수입니다. 다음 명령을 마크다운 문서를 HTML로 변환하는 R 스크립트입니다. 메시지를 보면 Pandoc이 호출되어 HTML을 생성함을 유추할 수 있습니다.\n\npandoc(\"example-1.md\", format = \"html\")\nExecuting: pandoc -t html -o 'example-1.html' 'example-1.md'\n[1] \"example-1.html\"\n\n생성된 HTML 파일인 example-1.html이 웹 브라우저에 표현된 내용은 다음과 같습니다.\n생성된 HTML 파일의 랜더링 화면\nRStudio를 사용하면 이런 몇 단계의 작업을 메뉴 하나로 함축해 놓았기 때문에, 그냥 메뉴 아이콘을 눌러 작업할 수 있습니다. 그래서 단계적으로 함수를 호출하는 것을 모르는 R 사용자가 대부분입니다. 지극히 정상입니다. 다만 RStudio를 사용하지 않는 R 사용자는 단계적으로도 작업을 할 수 있도록, 함수를 호출하는 방법을 숙지해야 합니다.\n\nrmarkdown 패키지\nSweave와 knitr는 문서에 삽입된 R 코드 청크를 실행하고 그 결과를 LaTeX이나 마크다운 문서에 삽입하는 작업을 수행합니다. 그러나 이 작업은 최종 문서를 만드는 작업의 일부입니다. R 마크다운 파일이 문서가 되기 위해서는 다음의 워크플로우를 거쳐야 합니다. 이 작업을 수행해 주는 것이 rmarkdown 패키지입니다.\n\n\n\n\n\n\n\n\n\n\nrmarkdown는 마크다운과 R 코드를 연동하여 재현 가능한 문서를 작성할 수 있는 R 패키지입니다. 마크다운의 마크업 태그는 파일에 저장된 코드를 실행한 결과와 매시업되어 사용자가 의도한 저작 콘텐츠를 고품질의 문서로 자동으로 생성해 줍니다.  R Markdown 문서는 재현 가능하며 수십 가지의 정적 및 동적 출력 형식을 지원합니다.\n\n\nR 마크다운은 보고서만 만드는 도구가 아닙니다. R 마크다운을 이용하면 다음 그림6처럼 블로그와 같은 웹 페이지를 만들 수도 있으며, 서적도 출판할 수 있습니다.\nDocument your analyses, make a website, make slides… the world is your oyster!R 마크다운을 소개하는 이 웹 페이지도 rmarkdown 기반으로 만들었습니다. (정확히 말하자면 distill 패키지를 이용한 R 마크다운 파일의 웹 페이지 생성)\n많은 문서들이 웹 페이지로 생산되고, 배포 공유되는 세상입니다. R 마크다운을 이용해서 재현 가능한 문서를 생산하는 것을 적극 추천합니다. 특히 RStudio는 R 마크다운을 생산하고 배포하는 기능을 쉽게 메뉴화했습니다. 어렵게 느끼지 말고, R 기반의 데이터 분석 경험을 적극 자산화하고 공유하시기 바랍니다.\n\n\n\nLeisch, Friedrich. 2002. “Sweave: Dynamic Generation of Statistical Reports Using Literate Data Analysis.” In Compstat 2002 - Proceedings in Computational Statistics, edited by Wolfgang Härdle and Bernd Rönz, 575–80. Physica Verlag, Heidelberg. http://www.stat.uni-muenchen.de/ leisch/Sweave.\n\n\nhttps://ko.wikipedia.org/wiki/서식_있는_텍스트_포맷. 서식 있는 텍스트 포맷 또는 리치 텍스트 포맷(Rich Text Format, 줄여서 RTF)은 마이크로소프트사가 1987년에 개발한 규격인 사유의 문서 파일 형식이며 크로스 플랫폼 문서 교환을 위하여 만들어졌다.↩︎\nhttps://ko.wikipedia.org/wiki/마크다운 발췌↩︎\nhttps://pandoc.org/MANUAL.html 발췌↩︎\nknitr ≈ Sweave + cacheSweave + pgfSweave + weaver + animation::saveLatex() + R2HTML::RweaveHTML() + highlight::HighlightWeaveLatex() + 0.2 * brew + 0.1 * SweaveListingUtils + more↩︎\nknitr 홈페이지 https://yihui.org/knitr/ 발췌↩︎\nhttps://www.williamrchase.com/slides/ggplot_intro.html#57↩︎\n",
      "last_modified": "2021-11-05T08:12:55+09:00"
    },
    {
      "path": "RStudio.html",
      "title": "첫 R 마크다운 문서 만들기",
      "description": "RStudio에서 R 마크다운 문서를 활용하는 방법을 익힙니다.\n",
      "author": [
        {
          "name": "유충현",
          "url": "https://choonghyunryu.github.io/"
        }
      ],
      "date": "2021-10-31",
      "contents": "\n\nContents\nR 마크다운 문서 만들기\nR 마크다운 문서 만들기\nR 마크다운 문서 저장하기\n\nHTML 생성하기\n보고서 파일 생성하기\n보고서 파일 살펴보기\n\n요약\n핸즈온 요약\nI can do it\n\n\n\n\n\n\n\n들어가기\nRStudio를 제대로 사용하는 것은 R 마크다운을 사용할 줄 안다는 것입니다.\n\nRStudio는 재현가능한 연구를 위한 최적의 솔루션이기 때문입니다. 이제 여러분은 RStudio를 제대로 사용할 수 있게 됩니다.\n\n운영체제에 따라 화면 모습에 다소 차이가 있을 수 있습니다. 염두에 두시기 바랍니다.\n\n\nR 마크다운 문서 만들기\nR 마크다운 문서를 생성하는 방법을 학습합니다. 지시에 따라 R 마크다운 파일을 생성합니다.\nR 마크다운 문서 만들기\nRStudio에서 R 마크다운 문서를 만들어 보겠습니다. RStudio의 좌측 상단의 새로운 파일 생성 아이콘을 누른 후, 메뉴에서 “R Markdown…”을 선택합니다.\n새 파일 만들기 아이콘New R Markdown 다이얼로그에서 다음을 입력하고 ‘OK’ 버튼을 누르세요.\n제목에 ’첫 R 마크다운’을 입력합니다.\n저자에 당신의 이름을 입력합니다. 예시에는 ’홍길동’을 입력했습니다.\n출력 포맷에서 HTML을 선택합니다. 기본값입니다.\n‘OK’ 버튼을 눌러, R 마크다운 문서를 생성하세요.\nNew R Markdown 다이얼로그다이얼로그의 왼쪽 헤더에는 R 마크다운의 종류를 선택할 수 있는 메뉴가 있습니다. 메뉴를 선택하면, 오른쪽에 해당 메뉴에 따라 R 마크다운 파일을 생성하는 옵션들이 나타납니다.\nDocument\n정적 문서(static documents)를 생성하기 위한 메뉴입니다.\nHTML, PDF, 워드 파일을 생성할 수 있습니다.\n\nPresentation\n발표 슬라이드를 생성하기 위한 메뉴입니다.\nHTML, PDF, 파워포인트 파일의 슬라이드를 생성할 수 있습니다.\n\nShiny\nShiny 기반의 동적 문서(dynamic documents)를 생성하기 위한 메뉴입니다.\nShiny 웹앱이나 Shiny 슬라이드를 생성합니다.\n\nForm Template\n특정 목적을 위해서 미리 준비한 R 마크다운 문서 템플리트를 사용하는 메뉴입이다.\n관련 템플리트를 지원하는 R 패키지가 설치되어야 합니다.\n\n\n\n\n\n솔루션\n\nNew R Markdown 다이얼로그를 여는 방법은 두가지입니다. 튜토리얼에서 제시하는 메뉴 아이콘 선택 방법과 \"File > New File > Markdown File\" 메뉴를 이용하는 방법입니다. 메뉴 아이콘 이용 방법이 간결하고 쉽습니다.\n\n\n메뉴를 이용하는 방법생성된 R 마크다운 템플리트 문서를 살펴보세요.\n제목과 당신의 이름은 어느 위치에 표현되어 있습니까?\n’output:’은 어떻게 기술되어 있습니까?\n어떤 내용의 문서를 생성할 것이지를 이야기해 보세요.\n두 개의 R 코드 청크를 해석해 보세요.\n‘pressure’ 청크는 어떤 플롯을 그리는 것일까요?\n\nR 마크다운 문서의 이름이 ’Untitled1’인 것을 확인하세요.\n아직은 파일로 저장되지 않은 상태입니다.\n\n생성된 R 마크다운 템플리트 문서R 마크다운 문서 저장하기\n생성된 R 마크다운 파일의 이름이 정해지지 않았음을 발견했습니다.\n좌측 상단의 디스켓 모양의 아이콘을 눌러 파일을 저장하세요.\n파일 이름에 ’first_rmarkdown’을 입력하세요.\n‘Save’ 버튼을 눌러 파일을 저장하세요.\n\n생성된 R 마크다운 템플리트 문서HTML 생성하기\nRStduio는 knitr을 이용해서 R 마크다운 문서를 마크다운 문서로 변환합니다. 그래서 메뉴에 ‘knit’라고 표현하는 것은 지정한 포맷의 보고서 파일을 생성하라는 의미입니다.\n마크다운 문서로 최종 보고서 파일을 생성하는 방법을 학습합니다. 지시에 따라 보고서 파일을 생성합니다.\n보고서 파일 생성하기\n좌측 상단의 뜨개실 이미지 아이콘을 눌러 보고서 파일을 생성하세요.\n뜨개실 이미지 아이콘 옆에 ’Knit’라는 문자열과 역삼각형 이미지를 확인하세요.\n’Knit’라는 문자열과 역삼각형 이미지를 클릭하세요.\n주의) 역삼각형 이미지가 아닌 ‘Knit’ 문자열을 클릭하면 메뉴의 팝업없이 바로 실행됩니다.\n\n팝업된 메뉴에서 ’Knit to HTML’을 눌러 보고서 파일을 생성합니다.\nknit 메뉴 아이콘팝업 메뉴에는 최종 파일의 포맷을 선택하는 기능, 파라미터를 추가하는 메뉴 등이 포함되어 있습니다.\nKnit to HTML\nHTML 문서를 생성합니다.\n\nKnit to PDF\nPDF 문서를 생성합니다.\n\nKnit to Word\n워드 문서를 생성합니다.\n\nKnit with Parameters…\nR 마크다운 문서에 입력 파라미터를 설정했을 경우, 파라미터의 값을 정의합니다.\n\nKnit Directory\n생성한 최종 보고서를 저장할 경로를 설정합니다.\nDocument Directory\nR 마크다운 파일이 있는 디렉토리에 저장합니다.\n기본값입니다.\n\nProject Directory\nR 프로젝트 안에서의 R 마크다운 파일일 경우, 프로젝트 루트에 저장합니다.\n\nCurrent Working Directory\n현재 R 작업 경로에 저장합니다.\n\n\n보고서 파일 살펴보기\n브라우저에 출력된 HTML 문서를 확인하세요.\n제목과 저장 이름이 출력된 위치와 크기를 확인하세요.\nR 코드 청그 위치에 어떤 내용이 표시되어 있습니까?\nHTML 본문의 https://rmarkdown.rstudio.com을 눌러보세요.\n\n브라우저에 출력된 HTML 문서요약\n핸즈온 요약\nR 마크다운 문서를 생성했습니다.\nR 마크다운 문서로 HTML 문서를 생성했습니다.\nI can do it\nRStudio의 메뉴를 이용해서 R 마크다운 문서를 작성하고, R 마크다운 문서의 R 코드 청크를 실행하여 HTML 문서를 생성할 수 있습니다.\n\n\n\n",
      "last_modified": "2021-11-05T08:12:56+09:00"
    },
    {
      "path": "understand_markdown.html",
      "title": "마크다운 태그 이해하기",
      "description": "마크다운 태그로 다양한 서식의 문서를 문들 수 있습니다.\n",
      "author": [
        {
          "name": "유충현",
          "url": "https://choonghyunryu.github.io/"
        }
      ],
      "date": "2021-10-31",
      "contents": "\n\nContents\nNot Yet\n요약\n핸즈온 요약\nI can do it\n\n\n\n\n\n\n\n\n들어가기\nooooooooooooooooooooooooooooooooooo.\n\nooooooooooooooooooooooooooooooooooo.\n\n\nNot Yet\n요약\n핸즈온 요약\nI can do it\n\n\n\n",
      "last_modified": "2021-11-05T08:12:56+09:00"
    }
  ],
  "collections": []
}
